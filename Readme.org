#+AUTHOR:    Aziz Yemloul
#+EMAIL:     azizyemloul@gmail.com
#+CREATOR:
#+DESCRIPTION:
#+LANGUAGE:  fr
#+HTML_DOCTYPE: html5
#+OPTIONS:   H:3 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:t p:t todo:t stat:t pri:nil tags:t
#+OPTIONS:   html5-fancy:t html-postamble:nil html-preamble:nil
#+OPTIONS:   timestamp:nil author:nil creator:nil email:nil c:t e:t inline:t
#+TITLE:
* Objectif
Formaliser   le   fonctionnement   d'une  équipe   de   collaborateurs
travaillant sur un projet de développement.
* La notion de workflow
Une dépôt ~Git~ centralise le travail de plusieurs intervenants sur un
projet de développement.

La prise en main de ce logiciel  n'est pas intuitive. La mise en place
d'un schéma de  fonctionnement de base permettra  de l'exploiter avant
de le maîtriser.

* Le dépôt
Chaque collaborateur commence par héberge sur son ordinateur une copie
du dépôt central.

#+BEGIN_SRC sh
git clone adresse_du_depot nom_local
#+END_SRC

#+BEGIN_HTML
<img src="./img/collab0.png" width=200 height=200 />
#+END_HTML

À chaque fois  qu'il l'estime nécessaire, un collaborateur  met à jour
le dépôt central en envoyant l'état d'avancement de son travail.

#+BEGIN_HTML
<img src="./img/bob_push.png" width=200 height=200 />
#+END_HTML

#+BEGIN_SRC sh
git add .
git commit -m "Message descriptif des ajouts"
git push
#+END_SRC

Si un autre collaborateur souhaite  à son tour envoyer l'avancement de
son travail, l'état du dépôt central aura changé.

#+BEGIN_HTML
<img src="./img/mary_failed_push.png" width=200 height=200 />
#+END_HTML

Le ~push~ échouera alors, avec un message d'erreur semblable au suivant :
#+BEGIN_EXAMPLE
$ git push
 ! [rejected]        master -> master (fetch first)
error: impossible de pousser des références vers 'adresse_du_depot'
astuce: Les mises à jour ont été rejetées car la branche distante contient du travail que
astuce: vous n'avez pas en local. Ceci est généralement causé par un autre dépôt poussé
astuce: vers la même référence. Vous pourriez intégrer d'abord les changements distants
astuce: (par exemple 'git pull ...') avant de pousser à nouveau.
astuce: Voir la 'Note à propos des avances rapides' dans 'git push --help' pour plus d'information.
$
#+END_EXAMPLE

* La gestion des conflits
~Git~   offre    différentes   possibilités   pour    résoudre   cette
situation.  Celle  présentée  ci-dessous   offre  l'avantage  de  nous
familiariser avec le logiciel.

** La stratégie à la ~fetch~ ~merge~
La  commande   ~git  fetch~  permet   de  récupérer  le   nouvel  état
d'avancement  du  dépôt  et  le mettre  dans  un  emplacement  virtuel
~origin/master~ sans écraser le travail effectué par le collaborateur.

#+BEGIN_SRC sh
$ git fetch
remote: Counting objects: 5, donne.
remote: Compressing objects: 100% (2/2), donne.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), donne.
Depuis adresse_du_depot
   7f934c9..a25526d  master     -> origin/master
$
#+END_SRC

La  commande  ~git  merge  origin/master~ rassemblera  la  version  du
serveur avec le travail déjà  effectué par le collaborateur en faisant
ressortir les conflits qu'il pourra résoudre à son aise.

#+BEGIN_SRC sh
$ git merge origin/master
Fusion automatique de README.md
CONFLIT (contenu) : Conflit de fusion dans README.md
La fusion automatique a échoué ; réglez les conflits et validez le résultat.
$
#+END_SRC

Les conflits, ici contenus dans le fichier ~README.md~ pour l'exemple,
seront clairement délimités par ~Git~ grâce à des marqueurs clairs.

#+BEGIN_EXAMPLE
<<<<<<< HEAD
La version
locale
=======
La version
du dépôt central
>>>>>>> origin/master
#+END_EXAMPLE

Le collaborateur n'aura qu'à choisir  quelle portion du code garder et
celle qu'il désactivera en la  commentant avant d'envoyer sur le dépôt
central.  Il   devra  avant  cela  également   enlever  les  marqueurs
introduits par ~Git~ pour indiquer les conflits :

#+BEGIN_EXAMPLE
<<<<<<< HEAD
=======
>>>>>>> origin/master
#+END_EXAMPLE

#+BEGIN_SRC sh
$ git commit -m "Merge de conflits avec la version du dépôt central"
$ git push
#+END_SRC

** ~Git~, un logiciel aux possibilités larges
~Git~ était au départ un système de fichier optimisé qui a évolué vers
un  système de  gestion  de  version centralisé.  Cette  aspect de  sa
conception lui donne une grande flexibilité.

La gestion  des conflits  comme nous avons  vu précédemment  peut être
conduite selon plusieurs stratégies. [[alarebase.org][À la rebase]] par exemple.

Il existe néanmoins une autre  stratégie qui est considéré aujourd'hui
comme une spécificité grâce à  laquelle ~Git~ surpasse ses concurrents
dans le domaine de la gestion centralisée du travail collaboratif, les
branches.

C'est cette spécificité que nous  souhaitons exploiter de manière plus
poussée et qui  donnera lieu à de nouveaux documents  dans le cadre de
ce projet de formalisation d'un workflow.

* Autres liens
- http://documentup.com/skwp/git-workflows-book
- http://scottchacon.com/2011/08/31/github-flow.html
- https://guides.github.com/introduction/flow/index.html
- http://www.toptal.com/git/git-workflows-for-pros-a-good-git-guide
- https://sandofsky.com/blog/git-workflow.html
- https://git-scm.com/book/en/v2/Git-Branching-Branching-Workflows
- http://nvie.com/posts/a-successful-git-branching-model/

* Notes
Illustrations tirée depuis [[https://www.atlassian.com/git/tutorials/comparing-workflows][ce site]]
